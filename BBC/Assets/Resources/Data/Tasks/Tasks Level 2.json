{
  "Items": [
    {
      "ID": 1,
      "Title": "Первая развилка",
      "Description": "  - Напиши условную конструкцию if: if (isRightPointerHere) {...}\n  - Внутри (в фигурных скобках) верни 1, если условие истинно\n  - Ниже (после фигурных скобок) верни 0",
      "ExtendedDescription": "     Ну вот и первая загвоздка: куда идти? Вроде бы указатели есть, да только слова на них затёрлись и ни одной буквы не разобрать. Что ж, будем придерживаться такой стратегии: чтобы не потеряться, на каждой развилке будем идти вправо.\n     Теперь нужно, чтобы робот смог понять, куда надо двигаться. Мы должны сказать ему: \"Иди вправо, если туда ведёт указатель.\" Как сделать это с помощью кода?\n     На помощь нам придут специальные <b><color=green>условные конструкции</color></b>, которые выполняют определённые действия в зависимости от того, выполнено некое <b><color=green>условие</color></b> или нет. Такие конструкции используют специальный тип данных <b><color=green>bool</color></b>, принимающий значения <b><color=green>true</color></b> (истина) и <b><color=green>false</color></b> (ложь). Этот тип могут иметь как переменные, так и некоторые выражения.\n     Итак, самой важной конструкцией является <b><color=green>if</color></b> (\"если\"). Принцип её работы: если некоторое условие истинно (имеет значение true), то программа выполняет некоторые инструкции.\n       if (/* условие */)\n       {\n          /*\n             Блок кода\n          /*\n       }\n     Её мы и используем для решения первой задачи: нам нужно сказать роботу идти вправо, если есть указатель в ту сторону. Зрительные анализаторы робота определят наличие указателя и передадут информацию как <b><color=green>аргумент</color></b> метода. Если указатель будет обнаружен - вернём программе робота единицу, а в противном случае - ноль.",
      "StartCode": "public int Execute(bool isRightPointerHere)\n{\n    \n    \n}\n"
    },
    {
      "ID": 2,
      "Title": "Что здесь росло?",
      "Description": "  - Напиши условие, используя if: если количество бревён logsCount больше либо равно 8, верни первый тип дерева (1)\n  - В качестве действия в противном случае, верни (после всей условной конструкции) второй тип дерева (2)\n",
      "ExtendedDescription": "     Кажется, стратегия \"идти всегда вправо\" быстро дала сбой - мы пришли в тупик. Но раз уж мы пришли сюда, немного потренируемся использовать условия.\n     Как мы уже говорили, в условие для if мы можем записать не только переменные типа bool, но и некоторые выражения. Самые распространённые и очевидные - это <b><color=green>операции сравнения</color></b> чисел. Это ==, >, <, <=, >=, !=.\n       1 == 1   // 1 равно 1, выражение равно true\n       5 > 3    // 5 больше 3, выражение равно true\n       4 <= 2   // 4 меньше или равно 2, выражение равно false\n       number != 9   // number не равно 9, значение выражения зависит от значения number\n     В конструкции if они используются также, как и переменные типа bool:\n       if (number > 10)\n           return true;\n     В последнем примере мы записали конструкцию if без фигурных скобок. И так можно делать, но только если блок кода после условия занимает одну строчку. В остальных случаях их наличие обязательно.\n     Теперь решим задачку. Мы с вами зашли в тупик, но похоже здесь излюбленное место дровосеков: много пеньков, лежащие кучами брёвна... Было бы неплохо подзарядить робота, и древесина нам как раз пригодится. Как бы сделать так, чтобы и робота зарядить, и много дров у дровосеков не забирать?\n     Известно, что больше энергии при сгорании выделяет древесина хвойных деревьев. У каждого пенька лежат брёвна. По размеру они одинаковые, только количество отличается. Узнаем, какое дерево было на месте каждого пенька.\n     Если брёвен очень много, то скорее всего, это высокая сосна, а если не так много, то это дуб. Для простоты обозначим сосну типом дерева 1, а дуб - типом дерева 2.\n",
      "StartCode": "public int Execute(int logsCount)\n{\n    \n    \n}\n"
    },
    {
      "ID": 3,
      "Title": "Новая стратегия",
      "Description": "  - Создай целочисленную переменную номера пути pathNumber\n  - Напиши условие: если указатель налево есть, присвой pathNumber значение 1, а иначе - значение 2.\n  - После всех условий верни номер пути, умноженный на 800.",
      "ExtendedDescription": "     Прошлая наша стратегия не сработала. Попробуем другую: на каждой развилке будем сворачивать налево, если туда ведёт указатель, иначе пойдём направо.\n     Очевидно, чтобы выбрать маршрут, нужно проверить два условия. Но если первое выполнится, то нам не нужно проверять второе, однако программа это сделает, что не очень эффективно. Как это исправить?\n     Для таких случаев существует конструкция <b><color=green>else</color></b>, которая выполняет определённые инструкции только тогда, когда условие, переданное в if, ложно.\n       if (/* условие */)\n       {\n          /*\n             Блок кода\n          /*\n       }\n       else\n       {\n          /*\n             Блок кода\n          /*\n       }\n     Эта конструкция <b><color=green>if-else</color></b> весьма полезна и часто используется в программах. Самое время и нам её применить.\n     На указателях стёрлись названия, но видно расстояние: на левом - 800 метров, на правом - 1600. Определим длину дальнейшего маршрута робота по номеру выбранного пути!\n     Но напоследок - небольшое замечание.\n     Если в блоке if вы используете return, то писать else <b><color=green>НЕ нужно</color></b>, ведь return будет означать конец выполнения метода, а значит в другую ветку условий программа не пойдёт. Помните об этом!",
      "StartCode": "public int Execute(bool isLeftPointerHere)\n{\n    \n    \n}\n"
    },
    {
      "ID": 4,
      "Title": "Съедобно-несъедобно",
      "Description": "  - Напиши условие: если гриб имеет высоту больше 6, либо высоту меньше 4 и имеет пятна (isMushroomSpotted) и цвет шляпки красный (isMushroomRed), верни разницу между количеством съедобных и несъедобных грибов mushroomsDifference, уменьшенную на 1.\n  - В остальных случаях возвращай разницу, увеличенную на 1.",
      "ExtendedDescription": "     Да что ж такое-то! Первый раз свернули налево - а тут завал. Придётся снова возвращаться. Но чтобы время не прошло даром, расскажем вам ещё кое-что об условиях.\n     Взгляните на эти грибы. Вот какие, по-вашему мнению, съедобны? Мы вот, кроме мухоморов, ничего не знаем, а робот наш в этом деле и вовсе дилетант. Попробуем распознать мухомор.\n     У него два главных атрибута - красная шляпка и белые пятнышки на ней. Выходит, есть два условия. Как их проверить <b><color=green>одновременно</color></b>?\n     Можно вложить один if в другой:\n       if (/* условие 1 */)\n       {\n          if (/* условие 2 */)\n          {\n              /*\n                 Блок кода\n              /*\n          }\n       }\n     Полученная запись может использоваться, но она довольно громоздкая. К тому же, для нашего случая можно использовать кое-что получше, а именно - <b><color=green>логические операторы</color></b> && (логическое \"И\") и || (логическое \"ИЛИ\"). Они позволяют объединять несколько условий в одном if-е в самых различных комбинациях.\n       if (number > 10 && number < 20)\n       {\n          /*\n             Этот код выполнится, если number\n             будет больше 10, но меньше 20\n          /*\n       }\n     Зная это, мы можем определить (ну или хотя бы попытаться), какие грибы съедобные. Опираясь на наши феноменальные (нет) познания, будем считать несъедобными мухоморы и грибы-гиганты (ну мало ли что случится).",
      "StartCode": "public int Execute(int mushroomsDifference, int mushroomHeight, bool isMushroomSpotted, bool isMushroomRed)\n{\n    \n    \n}\n"
    },
    {
      "ID": 5,
      "Title": "Правильный выбор",
      "Description": "  - Создай целочисленную переменную номера пути pathNumber;  - Напиши условие: если первый путь свободен, а второй и третий - нет, присвой номеру пути значение 1\n  - Иначе, если второй путь свободен, а первый и третий - нет, присвой значение 2\n  - В противном случае присвой значение 3\n  - В конце верни номер пути, умноженный на 400",
      "ExtendedDescription": "     Всё! Довольно! Хватит с нас этих стратегий. Включим наш прагматизм и будем выбирать тот путь, на котором нет преград. Судя по нашему опыту, он тут везде один.\n     Мы уже многое знаем об условиях, и в задаче поиска пути нам пригодится недавно изученный else. Но если путей будет больше двух, как тогда быть? Писать неэффективный набор if-ов?\n     На самом деле, можно использовать ещё одну крайне полезную конструкцию - <b><color=green>else if</color></b>. Она позволяет выполнять другой набор действий, если условие в if не выполнилось, но условие в else if выполнилось. Проще проиллюстрировать это на примере:\n       if (/* условие 1 */)\n       {\n          /*\n             Блок кода. Выполнится, если условие 1 истинно\n          /*\n       }\n       else if (/* условие 2 */)\n       {\n          /*\n             Блок кода. Выполнится, если условие 1 ложно, а условие 2 истинно\n          /*\n       }\n       else\n       {\n          /*\n             Блок кода. Выполнится, если оба условия ложны.\n          /*\n       }\n     Таких else if можно использовать сколь угодно много, что даёт возможность заставлять программу работать по-разному в зависимости от разных ситуаций. Это нам на руку: теперь, наконец, можем найти правильный путь.\n     На указателях вновь только расстояние: на первом - 400 метров, на втором - 800, на третьем - 1200. Как и в прошлый раз, дадим роботу возможность рассчитать длину следующей части нашего маршрута.\n     Чуть не забыли! В прошлый раз, говоря об операторах, мы забыли упомянуть <b><color=green>отрицание</color></b>. Оно обозначается ! перед выражением или булевой (типа bool) переменной и меняет их значение на противоположное.\n     Например, !(10 == 10) благодаря отрицанию будет иметь значение false, хотя выражение внутри скобок истинно. Это знание нам тоже пригодится.",
      "StartCode": "public int Execute(bool isFirstPathClear, bool isSecondPathClear, bool isThirdPathClear)\n{\n    \n    \n}\n"
    },
    {
      "ID": 6,
      "Title": "Наводим мосты",
      "Description": "  - Используя условия, возвращай true, если длина бревна больше или равна 3, но меньше 5\n  - Иначе возвращай false",
      "ExtendedDescription": "     Кажется, мы рассказали вам всё самое основное и важное про условия. Пора применить все наши познания на практике, и перед нами как раз очень серьёзная проблема - моста через реку нет! Видимо, его унесло течением, и на другой берег теперь никак не добраться. Но, похоже, удача нас ещё не покинула: тут лежат брёвна и довольно большие, так что можно попробовать соорудить мост.\n     Поможем роботу подобрать нужные брёвна: достаточно длинные, чтобы достать до берега, но не слишком, чтобы он смог их поднять.",
      "StartCode": "public bool Execute(int logLength)\n{\n    \n    \n}\n"
    },
    {
      "ID": 7,
      "Title": "Тайный знак",
      "Description": "  - С помощью условий напиши программу, возвращающую номер пути:\n  - 1, если количество камней в башенке равно двум,\n  - 2, если количество камней в башенке равно шести,\n  - 3, если количество камней в башенке равно четырём\n  - В остальных случаях будем идти по первому пути (верни единицу)",
      "ExtendedDescription": "     И вновь развилка. И пути все вроде свободны. А слова на указателях нечитаемы. Что теперь делать?\n     Похоже, выход всё же есть. На примерной карте, имеющейся у робота, некоторые пути обозначены башенками из камней разной высоты. Похоже, это тайный знак для таких же искателей сокровищ, как мы.\n     Итак, ориентируясь на высоту башенок из камней, выберем правильный путь. Условия, как и всегда, нам помогут. Если что-то пойдёт не так, выберем путь интуитивно, ведь что ещё можно сделать в такой ситуации?",
      "StartCode": "public int Execute(int rocksCount)\n{\n    \n    \n}\n"
    },
    {
      "ID": 8,
      "Title": "Столько тайн, столько загадок...",
      "Description": "  - С помощью условий напиши программу, возвращающую номер пути:\n  - 1, если тайный символ (secretSymbol) - цифра 3,\n  - 2, если тайный символ - цифра 5,\n  - 3, если тайный символ - цифра 7\n  - 4 в остальных случаях",
      "ExtendedDescription": "     Ох уж эти загадки! Когда выход из леса так близок, они снова решили появиться. Надеемся, в последний раз...\n     Кажется, эти камни на тропинках образуют некие числа, но почему-то какие-то странные. Очевидно, это ещё один шифр.\n     И правда, на карте они также странно обозначены. Что ж, осталось найти соответствие и продолжить путешествие. Но прежде - небольшой секрет.\n     На самом деле, мы рассказали вам ещё не о всех условных конструкциях, но постараемся сделать это немного позже. Но об одной расскажем сейчас - это конструкция <b><color=green>switch</color></b>.\n     Она по своей сути напоминает сочетание if и else if, но позволяет писать более лаконичный и красивый код. Покажем это на примере:\n       int number = 2;\n       if (number == 2)\n         number += number;\n       else if (number == 3)\n         number += number * 2;\n       else number *= number;\n       \n       int number = 2;\n       switch (number)\n       {\n           case 2:\n               number += number;\n               break;\n           case 3:\n               number += number * 2;\n               break;\n           default:\n               number *= number;\n               break;\n       }\n       Конструкция switch будет в данном примере будет проверять совпадения значения number c одним из предусмотренных случаев (case), и если найдёт, выполнит определённый для набор комнад. Если совпадений не будет, будут выполнены команды по умолчанию (в блоке default). Чтобы последующие случаи не рассматривались, используется команда <b><color=green>break</color></b>. Однако, если в блоке case возвращается значение (т.е. используется <b><color=green>return</color></b>, то break писать <b><color=green>НЕ нужно</color></b> (похоже на ситуацию с else, не так ли?).\n       Как видно, в некоторых ситуациях предпочтительней использовать switch, а не if else, и мы, в свою очередь, рекомендуем это делать.\n       Эту (последнюю) задачу можно решить и с помощью switсh, и с помощью if else. Выбор за вами!",
      "StartCode": "public int Execute(int secretSymbol)\n{\n    \n    \n}\n"
    }
  ]
}