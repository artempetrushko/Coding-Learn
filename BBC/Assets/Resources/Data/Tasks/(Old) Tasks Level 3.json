{
  "Items": [
    {
      "ID": 1,
      "Title": "Чёрные ящики",
      "Description": "  - Создай переменную boxesCount, хранящую кол-во открытых ящиков, со значением 0.\n  - Вызови цикл for со следующими параметрами:\n  for (var i = 0; i < 4; i++) {...}\n  - В фигурных скобках специальный метод робота для открытия ёмкостей OpenContainer()\n  - Ниже (в теле цикла) увеличь boxesCount на 1.\n  - После цикла верни boxesCount",
      "ExtendedDescription": "     Похоже, впереди завал. Надо бы его расчистить, да нечем - ни топора, ни пилы у нас нет. Попробуем поискать, только вот с чего начать?\n     На причалах лежат ящики, и, возможно, в них найдётся что-нибудь полезное. Что ж, пишем небольшую программку роботу - и вперёд. Но... похоже, программа не получится короткой: ящиков немало, и чтобы поработать с каждым из них, придётся написать одинаковые команды тоже для каждого. Как бы сделать так, чтобы написать <color=green><b>один код</b></color> и использовать его <color=green><b>несколько раз</b></color>?\n     Тут нам пригодятся очень важные для программирования конструкции - <color=green><b>циклы</b></color>. Они позволяют выполнить набор инструкций определённое количество раз и могут помочь существенно сократить код. Во всех языках они, по сути своей, работают одинаково, поэтому это фундаментальное знание будет особенно полезно.\n     Познакомимся с первым из них - циклом <color=green><b>for</b></color>. Он вызывается одноимённым оператором и использует в своей работе счётчик, помогающий определить, сколько раз необходимо выполнить набор команд и когда остановиться. Покажем на примере:\n     var number = 1;\n     for (var i = 0; i < 5; i++)\n     {\n         number *= 2;\n     }\n     Вызывая цикл for, мы задаём ему некоторые параметры, разделённые точкой с запятой. Первый из них - это переменная-счётчик, которая и будет изменяться. Зачастую это целое число, но это может быть и другой тип. Далее идёт условие, при котором цикл продолжает работать. Если оно становится ложным, выполнение цикла прекращается. Последний параметр - то, как изменяется счётчик после выполнения очередной <color=green><b>итерации</b></color> (шага) цикла. Далее в фигурных скобках идёт набор инструкций. Здесь все пишется так же, как и в условиях, в т.ч. можно так же не писать скобки, если в цикле будет выполняться одна строчка кода.\n     Используя эти знания, попробуем решить нашу задачу: нам нужно открыть каждый ящик, чтобы потом найти что-нибудь, что поможет разобрать завал. С этого момента мы начнём активнее использовать встроенный функционал робота, т.е. сами будем <color=green><b>вызывать</b></color> методы, который были предзаписаны в его память. Их не так много, но вместе с нашими программами они дадут отличный результат. Поехали!",
      "StartCode": "public int Execute()\n{\n    \n    \n}\n"
    },
    {
      "ID": 2,
      "Title": "Хорошая находка",
      "Description": "  - Объявите переменную itemsCount (кол-во предметов в ящиках) со значением 7\n  - Объявите цикл for со следующими параметрами:\n    - В качестве итератора объявите переменную i со значением 0;\n    - Условие работы цикла - i меньше itemsCount\n    - Как меняется итератор - увеличивается на 1\n  - В теле цикла напишите условие: если текущий предмет топор (вызовите метод IsAxe()) или пила (вызовите метод IsSaw(), нужно подобрать предмет (вызовите метод PickUp()) и завершить работу цикла (break))",
      "ExtendedDescription": "     Отлично, с for познакомились, ящики открыты! Теперь нужно проверить их содержимое. Закрепим знания о цикле for, применив его в этом задании, однако кое-что изменим.\n     Поскольку количество итераций может меняться, было бы неплохо хранить его в отдельной переменной, что мы сейчас и сделаем. Вдобавок вспомним про условия и используем их, ведь нам нужно найти именно топор или пилу. Если наше условие выполнится, будем подбирать предмет с помощью готового метода. Но если мы найдём два таких предмета, что делать? Второй нам точно не нужен, поэтому взять нужно только один. Значит, нужно как-то изменить поведение цикла, подстроить его под нашу ситуацию.\n     Тут на помощь придут специальные операторы, применяемые в циклах. Их два - <color=green><b>continue</b></color> и <color=green><b>break</b></color>. Оператор continue запускает новую итерацию цикла, не дожидаясь выполнения остальных инструкций, а break завершает работу цикла.\n     Сейчас нам интересен только break, он поможет завершить работу цикла, как только мы найдём подходящий инструмент. Будем его использовать внутри if-а, а в качестве условий будут выступать результаты работы пары методов.\n     Стоп, а разве можно  методы в условиях? Да, но только если они возвращают значение типа bool. Этим знанием мы будем пользоваться и в следующих заданиях.\n     Теперь приступим!",
      "StartCode": "public void Execute()\n{\n    \n    \n}\n"
    },
    {
      "ID": 3,
      "Title": "Путь свободен!",
      "Description": "  - Вызовите цикл while с условием !IsPathClear() (метод, проверяющий, свободен путь или нет, возвращает bool, из-за отрицания результат будет противоположный)\n  - В теле цикла вызовите метод UseAxe() (применение топора роботом)",
      "ExtendedDescription": "     Прекрасно! Мы нашли топор, а значит, мы можем попытаться убрать деревья с дороги. Если большие объекты робот не может передвинуть, то небольшие брёвна ему по силам. Осталось только написать программу.\n     Но вот вопрос: а сколько раз нужно выполнять команды в цикле? Деревьев много, довольно трудно посчитать их количество. Единственное, что мы знаем, так это когда нужно закончить - когда деревьев на дороге не останется. Есть ли способ выполнять программу, <color=green><b>пока</b></color> не выполнится некоторое условие?\n     Ответ - да. Нам пригодится другой очень важный цикл - <color=green><b>while</b></color>. Он не имеет счётчика и выполняет набор команд до тех пор, <color=green><b>пока</b></color> выполняется некоторое условие. Пример:\n     var number = 20.0;\n     while (number > 2)\n     {\n         number /= 2;\n     }\n     В данном примере переменная number будет уменьшаться в 2 раза, пока не станет меньше либо равной 2.\n     Удобство while заключается в том, что нам не нужно знать кол-во итераций, что полезно в некоторых ситуациях. В то же время нужно, чтобы условие остановки цикла могло однажды выполниться, иначе мы рискуем получить \"вечный\" цикл и нарушить работу программы.\n     Пришло время применить всё это на практике. Расчистим путь и продолжим наше путешествие! Как всегда, помимо циклов, нам помогут некоторые готовые методы.",
      "StartCode": "public void Execute()\n{\n    \n    \n}\n"
    },
    {
      "ID": 4,
      "Title": "Лесозаготовки",
      "Description": "  - Создай переменную treesCount (кол-во срубленных деревьев) со значением 0\n  - Объяви цикл: пока кол-во необходимых брёвен totalLogsCount больше 0, ...\n  - Внутри цикла вызывай метод использования топора UseAxe()\n  - Ниже увеличивай treesCount на 1\n  - Ниже напиши условие: если срубленное дерево высокое, уменьши totalLogsCount на 4, в противном случае уменьши на 2. Узнать, является ли дерево высоким, можно с помощью метода IsTreeTall() (возвращает true или false)\n  - После цикла верни treesCount",
      "ExtendedDescription": "     Мы всё ближе к деревне - уже различимы очертания домов и ограды. Пора перейти мост через реку. Вот только мост поднят, и хотя здесь есть рычаг, использовать его всё равно пока бесполезно: на мосту не хватает досок, а значит перейти никак не получится. Что ж, придётся нам самим его починить. Это нам по силам: в лесу мы уже восстанавливали переправу, так что есть опыт, к тому же, у нас есть топор, можно срубить деревья. Единственное, чего нам не хватает - программы.\n     Очевидно, что основой программы вновь станет цикл, но какой? Поскольку не ясно, сколько нам нужно срубить деревьев для моста, это будет while. Ещё надо учесть высоту деревьев, ведь с высоких можно получить больше брёвен. Условия, как и всегда, нас выручат.\n     Что ж, инструктаж окончен, приступаем к работе!",
      "StartCode": "public int Execute(int totalLogsCount)\n{\n    \n    \n}\n"
    },
    {
      "ID": 5,
      "Title": "Наводим мосты: Часть вторая",
      "Description": "  - Объяви цикл for, в котором итератор изменяется от 0 до partsCount с шагом 1\n  - В теле цикла вызови метод установки доски на мост SetUpBoard()\n  - Перед вызовом метода напиши условие: если номер текущей части моста (i) равен 2 или 7, переходим к следующей итерации (continue)",
      "ExtendedDescription": "     Самое тяжёлое позади, осталось прибить доски в нужных местах, и мост будет готов! Похоже, кто-то собирался чинить мост до нас, поэтому оставил здесь материалы и молоток. Он нам точно пригодится!\n     Что по программе? Всё просто: уже видно, сколько нам может понадобиться досок, поэтому условно разобьём мост на части и в for-е будем вызывать нужный метод. Но некоторые доски всё же сохранились, а значит там не надо их приколачивать. Как нам <color=green><b>пропустить</b></color> некоторые <color=green><b>итерации</b></color>?\n     В прошлых заданиях мы упоминали операторы циклов <color=green><b>continue</b></color> и <color=green><b>break</b></color>, но использовали только второй. Пришла очередь применить continue. Напомним, что он позволяет тут же завершить текущую итерацию цикла и перейти к следующей.\n     Вроде ничего сложного, поэтому приступим к починке моста!",
      "StartCode": "public void Execute(int partsCount)\n{\n    \n    \n}\n"
    },
    {
      "ID": 6,
      "Title": "Тщательный осмотр",
      "Description": "  - Объявите один из циклов. Определить, найден ли ключ, можно с помощью метода IsKeyFound() (возвращает true или false). Кол-во итераций (если необходимо) можно определить из кол-ва мест для осмотра (см. подробное описание по кнопке на панели задания)\n  - В теле цикла последовательно вызывайте методы ChooseNewPlace(), чтобы выбрать новое место для поиска, и SearchKey() для поиска ключа\n  - Если ключ был найден, цикл должен завершить работу",
      "ExtendedDescription": "     Один из ключей может быть здесь, в этой землянке. Она небольшая, так что сможем быстренько всё осмотреть.\n     Сейчас можно вновь попрактиковаться использовать циклы в программе: нам надо осмотреть <color=green><b>кровать</b></color> и ящики под ней, <color=green><b>письменный стол</b></color>, <color=green><b>верстак</b></color> и <color=green><b>бочку</b></color> в углу, чтобы, возможно, найти один из ключей. Выбор цикла оставляем за вами - это может быть как <color=green><b>for</b></color>, так и <color=green><b>while</b></color>. Кроме того, если пожелаете, можно использовать ещё один вид циклов - <color=green><b>do-while</b></color>. Как он выглядит?\n     do\n     {\n         //Код внутри цикла\n     }\n     while(/* условие */)\n     Он работает почти также, как while, только сначала выполняет инструкции в теле цикла, а уже затем проверяет условие. Цикл do-while встречается реже, но иногда может быть полезен, ведь код <color=green><b>гарантированно</b></color> выполнится <color=green><b>один раз</b></color>, даже если условие цикла изначально не выполняется.\n     Частью функций робот обладает, нужно лишь правильно их использовать в нашей программе. Удачи! ",
      "StartCode": "public void Execute()\n{\n    \n    \n}\n"
    },
    {
      "ID": 7,
      "Title": "Лотерея (почти)",
      "Description": "  - Объявите цикл for с числом итераций, равном числу сундуков\n  - В теле цикла объявите ещё один цикл for, кол-во итераций равно 5\n  - В теле внутреннего цикла вызывайте метод CheckNextItem() для осмотра следующего предмета\n  - Для проверки нахождения ключа используйте метод IsKeyFound() (возвращает true или false). Если он будет найден, завершайте работу цикла",
      "ExtendedDescription": "     Какой большой дом! Похоже, тут живёт кто-то очень важный, и наверняка один из ключей должен быть где-то здесь. Эта вещь очень ценная и, скорее всего, лежит в одном из этих сундуков, что стоят по всему дому. Придётся осмотреть их все, изучая каждый предмет в каждом сундуке.\n      Стоп, это что получается, для каждого сундука придётся написать цикл? Программа опять разрастётся до больших размеров!\n     Не спешите расстраиваться, ведь цикл - это такой же код, который, как и любой другой, можно <color=green><b>вложить</b></color> в тело <color=green><b>другого цикла</b></color>. Вот пример:\n     var number = 1;\n     for (var i = 0; i < 5; i++)\n     {\n         for (var j = 0; j < 5; j++)\n         {\n             number += i * j;\n         }\n     }\n     В данном примере на первой итерации <color=green><b>внешнего</b></color> цикла будет запущен <color=green><b>внутренний</b></color> цикл, а после того, как он полностью выполнится, начнется вторая итерация внешнего цикла, и так далее. Т.е. суммарно к number будет прибавлено 5 * 5 = 25 произведений чисел i и j.\n     Однако есть одна проблема: если нужно в какой-то момент прервать цикл, то одним break-ом обойтись не получится. В этом случае необходимо написать что-то вроде этого:\n     var flag = false;\n     for (...)\n     {\n         for (...)\n         {\n             ...\n             if (/* условие */)\n             {\n                 flag = true;\n                 break;\n             }\n         }\n         if (flag)\n             break;\n     }\n     Здесь применяется флаг - это, так сказать, переменная-индикатор, помогающая нам зафиксировать окончание внутреннего цикла досрочно. Во внешнем цикле мы проверяем её значение и, при необходимости, завершаем также внешний цикл.\n     Приём со вложенными циклами поможет нам решить следующую задачу. Осмотрим каждый предмет в каждом сундуке и, если ключ будет найден, завершим работу. Вперёд!",
      "StartCode": "public void Execute()\n{\n    \n    \n}\n"
    },
    {
      "ID": 8,
      "Title": "Маленький помощник",
      "Description": "  - Объявите цикл for, кол-во итераций должно быть равно кол-ву откапываемых предметов (4)\n  - В теле цикла вызывайте метод выбора новой цели TurnToNextTarget(), а затем метод вскапывания земли Dig(repeatsCount) (в качестве аргумента принимает число вскапываний). Кол-во вскапываний:\n    - для первого предмета - 2,\n    - для второго - 3,\n    - для третьего - 4,\n    - для четвёртого - 5.\n    Подумайте, как реализовать это в цикле\n  - Ниже (в цикле) проверяйте, найден ли ключ, с помощью метода IsKeyFound(возвращает true или false). Если он будет найден, завершайте работу цикла",
      "ExtendedDescription": "     Надо же, как много вещей тут разбросано и закопано! Должно быть, здесь играл ребёнок, как будто в песочнице, и игрушка тут стоит. Только это совсем не игрушка, а самый настоящий робот-копатель! Поскольку наш робот не предназначен для вскапывания земли (ручки коротковаты), этот маленький помощник нам пригодится. Надо откопать все предметы и, быть может, один из них окажется ключом от ворот!\n     Приступим!",
      "StartCode": "public void Execute()\n{\n    \n    \n}\n"
    }
  ]
}