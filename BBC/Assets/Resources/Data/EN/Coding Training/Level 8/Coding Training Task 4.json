{
  "Items": [
    {
      "Title": "Recursion",
      "Info": "In general terms, recursion is a phenomenon in which an object is part of itself. It is very clearly demonstrated, for example, by fractal shapes, matryoshka dolls, or an open window of a screen recording program that captures its own image .\n In the context of programming, recursion is a function that calls itself in the course of its work.Like loops, recursive functions are needed for multiple executions of some piece of code, while any recursive algorithm can be represented as loops.Why then it is necessary? In some cases, recursion is a good alternative to regular loops, since an algorithm written recursively may be simpler, shorter, more elegant, faster, or not. It all depends on the situation.\n Consider the example code in Block #1, which calculates the sum of all numbers from 1 to n inclusive:\n--IMAGE-- \nIt is written using a loop.Now consider code with the same functionality m, but written using the recursive function in Block #2.\n\n When creating a recursive function, it must necessarily contain some basic version for which we know the answer. In the case of the sum of all previous positive numbers, these are all numbers less than 1, since we are well aware that there are no positive integers that would be less than one, which means that their sum is zero. This will be the answer for the base solution, and it is what the function returns in the if block. \n If the input of the function is a value that is different from the base case, then it must eventually be reduced to the base case, otherwise we will end up with an infinite recursion.\n\nLet's consider step by step what will happen if Func(4) is called.\n\n n\n 1. First, it checks if the number is less than one:\n if (n < 1) return 0;\n \n But first, n is 4, so this condition is false, and the code is executed accordingly:\n return n + Func(n - 1);\n \n In fact, we have:\n return 4 + Func(3);\n \n\n 2. Next, the expression is executed:\n Func(3)\n \n Again but n is not less than 1, so the code is executed\n return n + Func(n - 1);\n \n In fact:\n return 3 + Func(2);\n \n\n 3. Next, the expression is executed :\n Func(2)\n \n Again, n is not less than 1, so the code is executed:\n return n + Func(n - 1);\n \n In fact:\n return 2 + Func(1 );\n \n\n 4. Next, the expression is executed:\n Func(1)\n \n Again, n is not less than 1, so the code is executed:\n return n + Func(n - 1);\n \n In fact:\n return 1 + Func(0);\n \n\n 5. Next, the expression is executed:\n Func(0)\n \n The base case condition is already satisfied here, since n is less than one, so 0 is returned, and the code is executed:\n if (n < 1) return 0;\n \n As a result, the expression Func(4) actually results in: 4 + 3 + 2 + 1 + Func(0). \n And since we know the answer for Func(0), we can calculate the entire expression: 4 + 3 + 2 + 1 + 0 = 10\n\n It is convenient to represent the calculation of the result in the form of function calls. First, the function recurses to the base case:\nFunc(4) = 4 + Func(3)\nFunc(3) = 3 + Func(2)\nFunc(2) = 2 + Func(1)\nFunc(1) = 1 + Func(0)\nFunc(0) = 0\n\n\nThen the chain starts to reverse:\nFunc(0) = 0\nFunc(1) = 1 + Func(0) = 1 + 0 = 1\nFunc(2) = 2 + Func(1) = 2 + 1 = 3\nFunc(3) = 3 + Func(2) = 3 + 3 = 6\nFunc(4) = 4 + Func(3) = 4 + 6 = 10\n\n Remember: if you want to get some end result, then\nany recursive function must have a base case, and recursive calls must somehow lead to it. \n\nFor example, if we slightly change our function and replace the '<' sign with '==', then at first glance, nothing will change, and the function will still work correctly for positive numbers, however, if we now input is a negative number, then the recursion will never be reduced to the base case, since we defined it to be one.\n\nThus, the call stack for the number -5 will look like this: Func(-5), Func(-6), Func(- 7)... This shows that we will never reach the base case n == 1 and eventually get the message: “Stack overflow”, i.e. Stack Full.",
      "VideoTitles": "8.4"
    }
  ]
}