{
  "Items": [
    {
      "Title": "Рекурсия",
      "Info": "    Если говорить в общих чертах, то рекурсия - это такое явление, при котором объект является частью самого себя. Ее очень наглядно демонстрируют, например, фрактальные фигуры, матрешки или открытое окно записывающей экран программы, которая захватывает свое же собственное изображение. \n    В контексте программирования рекурсия - это функция, которая в процессе своей работы вызывает сама себя. Как и циклы, рекурсивные функции нужны для многократных выполнений некоторого учатска кода, при этом любой рекурсивный алгоритм может быть представлен в виде циклов. Зачем же тогда он нужен? В некоторых случаях рекурсия является хорошей альтернативой обычным циклам, так как алгоритм, написанный рекурсивно может оказаться проще, короче, элегантнее, быстрее, а может и нет. Все зависит от ситуации.\n    Рассмотрим пример кода в Блоке №1, который вычисляет сумму всех чисел от 1 до n включительно:\n--IMAGE--  \nОн написан с применением цикла. Теперь рассмотрим код с тем же самым функционалом, но написанным с применением рекурсивной функции в Блоке №2.\n\n    При создании рекурсивной функции в ней обязательно должен быть некоторый базовый вариант, для которого мы знаем ответ. В случае с суммой всех предыдущих положительных чисел это все числа меньше 1, так как нам хорошо известно, что не существует положительных целых чисел, которые были бы меньше единицы, а значит и их сумма равна нулю. Это и будет являться ответом для базового решения, и именно его возвращает функция в блоке if. \n    Если же на вход функции поступило значение, отличное от базового варианта, то оно в конечном итоге должно обязательно сводиться к базовому, иначе получится бесконечная рекурсия.\n\nРассмотрим поэтапно, что будет в случае вызова Func(4).\n\n\n    1. Сначала идет проверка, меньше ли число единицы:\n       if (n < 1) return 0;\n    \n       Но вначале n равно 4, поэтому это условие ложно, и соответственно выполняется код:\n       return n + Func(n - 1);\n    \n       То есть фактически мы имеем:\n       return 4 + Func(3);\n    \n\n    2. Далее выполняется выражение:\n       Func(3)\n       \n       Опять же n не меньше 1, поэтому выполняется код\n       return n + Func(n - 1);\n       \n       То есть фактически:\n       return 3 + Func(2);\n       \n\n    3. Далее выполняется выражение:\n       Func(2)\n       \n       Опять же n не меньше 1, поэтому выполняется код:\n       return n + Func(n - 1);\n       \n       То есть фактически:\n       return 2 + Func(1);\n       \n\n    4. Далее выполняется выражение:\n       Func(1)\n       \n       Опять же n не меньше 1, поэтому выполняется код:\n       return n + Func(n - 1);\n       \n       То есть фактически:\n       return 1 + Func(0);\n       \n\n    5. Далее выполняется выражение:\n       Func(0)\n       \n       Здесь уже выполняется условие базового случая, так как n меньше единицы, поэтому возвращается 0, и выполняется код:\n       if (n < 1) return 0;\n       \n       В итоге выражение Func(4) в реальности выливается в: 4 + 3 + 2 + 1 + Func(0). \n       А так как для Func(0) нам известен ответ, то и все выражение мы можем посчитать: 4 + 3 + 2 + 1 + 0 = 10\n\n    Вычисление результата удобно представить в виде вызовов функции. Сначала функция посредством рекурсии доходит до базового случая:\nFunc(4) = 4 + Func(3)\nFunc(3) = 3 + Func(2)\nFunc(2) = 2 + Func(1)\nFunc(1) = 1 + Func(0)\nFunc(0) = 0\n\n\nЗатем цепочка начинает разворачиваться в обратном порядке:\nFunc(0) = 0\nFunc(1) = 1 + Func(0) = 1 + 0 = 1\nFunc(2) = 2 + Func(1) = 2 + 1 = 3\nFunc(3) = 3 + Func(2) = 3 + 3 = 6\nFunc(4) = 4 + Func(3) = 4 + 6 = 10\n\n    Помните: если вы хотите получить какой-то конечный результат, то\nу любой рекурсивной функции должен быть базовый случай, и рекурсивные вызовы должны так или иначе к нему приводить. \n\nНапример, если слегка изменить нашу функцию и заменить знак ‘<’ на ‘==’, то на первый взгляд, ничего не изменится, и функция будет по-прежнему корректно работать для положительных чисел,  однако, если теперь подать на вход отрицательное число, то рекурсия никогда не сведётся к базовому случаю, так как мы определили его равным единице.\n\nТаким образом стек вызова для числа -5 будет выглядеть так: Func(-5),  Func(-6),  Func(-7)... Отсюда видно, что до базового случая n == 1 мы никогда не дойдем и в конечном итоге получим сообщение: “Stack overflow”, т.е. “Стек переполнен”.",
      "VideoTitles": "8.2"
    }
  ]
}