{
  "LinkedThemeID": "Sorting algorithms",
  "Title": "Sorting algorithms",
  "SubThemes": [
    {
      "LinkedSubThemeID": "Introduction to algorithms",
      "Title": "Introduction to algorithms",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Algorithms and their efficiency",
          "Title": "Algorithms and their efficiency",
          "Info": "In programming, we often have to work with a set of data, such as searching for elements in it or sorting it. For such purposes, we use algorithms, and in general, we can say that the whole program is one continuous algorithm.\nAn algorithm represents is a sequence of steps that is designed to solve a specific problem.In other words, an algorithm is a way to solve this problem.\n\nAn important criterion for an algorithm is efficiency.An algorithm can perfectly solve a given problem, but be inefficient.As a rule, the efficiency of an algorithm means time for which this algorithm should be executed.You can also look at the efficiency of the algorithm in terms of the memory required for the operation, but we will not touch on this.\n"
        },
        {
          "LinkedTrainingInfoID": "Basic types of algorithm complexity",
          "Title": "Basic types of algorithm complexity",
          "Info": "The complexity of an algorithm indicates how many operations the algorithm will, in the worst case, perform before returning the correct answer. Depending on the efficiency, there are many types of algorithms, among which the following can be distinguished (listed in order of decreasing efficiency):\n\n1 .Const\nPerforms a fixed number of operations, which usually take constant time.For example, imagine an algorithm that prints the first 5 elements from an array to the screen.Then in the worst case, it will have to perform 5 iterations, and if the array is short, length is only 3, then the algorithm performs only 3 iterations.\n"
        },
        {
          "LinkedTrainingInfoID": "2. Logarithmic (logN)",
          "Title": "2. Logarithmic (logN)",
          "Info": "Hereinafter, N is the size of the input data to the algorithm.\nThe logarithmic algorithm runs slower than programs with constant time. The increase in execution time as N grows will increase by some constant amount.\n"
        },
        {
          "LinkedTrainingInfoID": "3. Linear (N)",
          "Title": "3. Linear (N)",
          "Info": "Here, the execution of the method depends on n. What value for n will be passed to the method, the number of times the loop will be executed. That is, the increase in the complexity of the algorithm for this method is proportional to the value of n, which is why it is called linear.\n"
        },
        {
          "LinkedTrainingInfoID": "4. Quadratic (N^2)",
          "Title": "4. Quadratic (N^2)",
          "Info": "As a rule, the methods that correspond to this algorithm contain two loops - an outer and a nested one, which are executed for all values ​​up to N.\n\nThere are other variations, and we will touch on one of them a little later. Worth also note that complexity is usually denoted by the letter “O.” For example, for a quadratic algorithm, the complexity will be O(N^2).This letter has a certain meaning, but for now we will not go deep into it and we will assume that it is simply indicates difficulty.\n"
        },
        {
          "LinkedTrainingInfoID": "Bubble Sort",
          "Title": "Bubble Sort",
          "Info": "Bubble sort is one of the most well-known sorting algorithms. Here you need to sequentially compare the values of adjacent elements and swap numbers if the previous one is greater than the next one. This way, elements with larger values end up at the end of the list, while those with smaller values remain at the beginning .\n\nThis algorithm is considered educational and almost never used in practice due to low efficiency: it is slow on tests in which small elements (called turtles) are at the end of the array.However, many other methods are based on it, for example, shaker sort and comb sort.The complexity of such an algorithm is quite large - O(N^2)"
        },
        {
          "LinkedTrainingInfoID": "Bubble Sort Algorithm",
          "Title": "Bubble Sort Algorithm",
          "Info": "Video demo"
        }
      ]
    },
    {
      "LinkedSubThemeID": "Comb Sorting",
      "Title": "Comb Sorting",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Comb Sorting",
          "Title": "Comb Sorting",
          "Info": "Comb sort is an improvement on bubble sort. Its idea is toeliminate elements with small values at the end of the array, which slow down the algorithm. If bubble sort compares adjacent elements when iterating over an array, then when combing, a sufficiently large distance between the compared values is taken first, and then it narrows down to the minimum.\n\nThe initial gap should not be chosen randomly, but taking into account a special value - a reduction factor, the optimal value of which is 1.247. elements will be equal to the size of the array divided by 1.247, at each subsequent step the distance will again be divided by the reduction factor - and so on until the end of the algorithm."
        },
        {
          "LinkedTrainingInfoID": "Comb Sorting Algorithm",
          "Title": "Comb Sorting Algorithm",
          "Info": "This is only a partial implementation of the algorithm. Here you need to add the CombSort method in the ellipsis to make it work. \n–IMAGE–"
        }
      ]
    },
    {
      "LinkedSubThemeID": "Quick Sort",
      "Title": "Quick Sort",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Quick Sort",
          "Title": "Quick Sort",
          "Info": "This algorithm is one of the most efficient.\nIt consists of three steps. First, one element must be selected from the array - it is usually called the pivot. Then the other elements in the array are redistributed so that elements less than the pivot are before it , and greater or equal - after. And then recursively apply the first two steps to the subarrays to the right and left of the reference value.\n–GIF–"
        },
        {
          "LinkedTrainingInfoID": "Quick Sort Implementation",
          "Title": "Quick Sort Implementation",
          "Info": "Shown in video clip"
        }
      ]
    },
    {
      "LinkedSubThemeID": "Merge Sort",
      "Title": "Merge Sort",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Merge Sort",
          "Title": "Merge Sort",
          "Info": "Merge sort is useful for data structures where elements are accessed sequentially (for example, for streams). Here, the array is split into two approximately equal parts and each of them is sorted separately. Then the two sorted subarrays are merged into one .\n-GIF-"
        },
        {
          "LinkedTrainingInfoID": "Merge Sort Implementation",
          "Title": "Merge Sort Implementation",
          "Info": "Video clip demonstration"
        }
      ]
    },
    {
      "LinkedSubThemeID": "Binary Search",
      "Title": "Binary Search",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Binary Search",
          "Title": "Binary Search",
          "Info": "If you are given a random array of elements and you need to find one of them in it, then you have no choice but to simply iterate one element after another until the desired one is found. This algorithm is called linear search, and unfortunately, it's impossible to do some clever trick here and significantly speed up the search.\n\nHowever, if you know something about the data array, for example, that it is sorted, then the situation changes dramatically. look at its middle element, then you will be able to determine exactly which half your desired number lies in. Because, it is either greater than the middle element, in which case you need to continue searching on the right side of the array, or it is less, in which case you need to look on the left. Or if you're lucky, the middle element will be the one you're looking for, in which case you don't need to keep searching. i binary"
        },
        {
          "LinkedTrainingInfoID": "Binary Search Implementation",
          "Title": "Binary Search Implementation",
          "Info": "The binary search algorithm looks like this:\n 1. “Divide” the array in half and find the middle.\n 2. Compare the middle element with the given desired element.\n 3. If the desired number is greater than the average, continue searching in the right parts of the array (if it is sorted in ascending order): divide it in half, repeating step 2. If the specified number is less, the algorithm will continue searching in the left side of the array, again returning to step 2.\n–IMAGE–"
        }
      ]
    }
  ]
}