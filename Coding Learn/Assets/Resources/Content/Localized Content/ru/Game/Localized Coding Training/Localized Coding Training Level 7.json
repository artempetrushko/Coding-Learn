{
  "LinkedThemeID": "Collections",
  "Title": "Коллекции",
  "SubThemes": [
    {
      "LinkedSubThemeID": "Introduction to List",
      "Title": "Знакомство с List",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Initializing a List Collection",
          "Title": "Инициализация коллекции List",
          "Info": "Хотя в языке C# есть массивы, которые хранят в себе наборы однотипных объектов, но работать с ними не всегда удобно. Например, массив хранит фиксированное количество объектов, однако что если мы заранее не знаем, сколько нам потребуется объектов. И в этом случае намного удобнее применять коллекции. Еще один плюс коллекций состоит в том, что некоторые из них реализует стандартные структуры данных, например, стек, очередь, словарь, которые могут пригодиться для решения различных специальных задач. Большая часть классов коллекций содержится в пространстве имен System.Collections.Generic.\n\nКласс List<T> из пространства имен System.Collections.Generic представляет простейший список однотипных объектов. Класс List типизируется типом, объекты которого будут хранится в списке.\n\nЭкземпляр класса List можно создать следующим образом:\nList<тип переменных> имя_листа = new List<тип переменных>();\n\nПри этом создается пустая коллекция, однако ее можно сразу заполнить необходимым набором элементов, указав их в фигурных скобках, либо передав другой список или массив в качестве параметра."
        }
      ]
    },
    {
      "LinkedSubThemeID": "Removing from the list",
      "Title": "Удаление из списка",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Removing from the list",
          "Title": "Удаление из списка",
          "Info": "Из списка можно удалять элементы различными способами, познакомимся с некоторыми из них:\n* RemoveAt() удаляет элемент по его индексу\n* Remove() удаляет элемент по его значению\n* RemoveRange() удаляет элементы по индексам в заданном диапазоне\n* people.Clear() полностью очищает список"
        }
      ]
    },
    {
      "LinkedSubThemeID": "Adding elements",
      "Title": "Добавление элементов",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Adding elements",
          "Title": "Добавление элементов",
          "Info": "В созданный список можно добавлять новые элементы. Один из способов сделать это - метод Add(). При этом элемент добавляется в конец списка."
        }
      ]
    },
    {
      "LinkedSubThemeID": "Search in the list and sort it",
      "Title": "Поиск в списке и его сортировка",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Search in the list and sort it",
          "Title": "Поиск в списке и его сортировка",
          "Info": "Список предоставляет возможность бинарного поиска элементов. Чем он отличается от обычного поиска в виде простого перебора, мы рассмотрим в одной из следующих тем. Пока что мы просто попробуем применить его для нахождения элементов. \nВажное уточнение: для работы бинарного поиска, список должен быть отсортирован. \n\nСортировку можно выполнить с помощью метода Sort(), а бинарный поиск с помощью метода BinarySearch()."
        }
      ]
    },
    {
      "LinkedSubThemeID": "Reverse order",
      "Title": "Обратный порядок",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Reverse order",
          "Title": "Обратный порядок",
          "Info": "У класса List есть метод Reverse(), который меняет порядок всех элементов на обратный."
        }
      ]
    },
    {
      "LinkedSubThemeID": "Introduction to Dictionary",
      "Title": "Знакомство с Dictionary",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Dictionary initialization",
          "Title": "Инициализация словаря",
          "Info": "Еще один распространенный тип коллекции представляют словари. Словарь хранит объекты, которые представляют пару ключ-значение. Класс словаря Dictionary<K, V> типизируется двумя типами: параметр K представляет тип ключей, а параметр V предоставляет тип значений. \n\nЕсли провести грубую аналогию, то можно сказать, что словарь - это список, но вместо его индексов может быть все что угодно и в любом порядке. Согласитесь, это удобно, если вам необходимо хранить пары данных вместе, например, слово и его перевод. Тогда в качестве ключа может выступать слово на вашем родном языке, а в качестве значения - перевод этого слова, или наоборот. Если же в данном случае обходиться только обычными списками, то вам понадобится либо два списка, либо один большой, данные в котором придется хранить в очень неудобном формате."
        }
      ]
    },
    {
      "LinkedSubThemeID": "Access to dictionary elements",
      "Title": "Доступ к элементам словаря",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Access to dictionary elements",
          "Title": "Доступ к элементам словаря",
          "Info": "Стоит отметить, что каждый элемент в словаре представляет структуру KeyValuePair<TKey, TValue>, где параметр TKey представляет тип ключа, а параметр TValue - тип значений элементов. Эта структура предоставляет свойства Key и Value, с помощью которых можно получить соответственно ключ и значение элемента в словаре.\n\nВы можете получить значение элемента словаря по его ключу, используя квадратные скобки, как в массивах и списках, а можете использовать цикл foreach для полного перебора. Обратите внимание, что обычный цикл for для перебора вам вряд-ли подойдет, так как индексами могут быть не только числа, да и словарь сам по себе не является упорядоченной коллекцией.\n\nДля получение ключа и значения элемента словаря используются свойства Key и Value соответственно."
        }
      ]
    },
    {
      "LinkedSubThemeID": "ContainsKey method",
      "Title": "Метод ContainsKey",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Hint",
          "Title": "Подсказка",
          "Info": "Для того, чтобы найти самые частые слова, вам придется посчитать, сколько раз каждое слово встречается в тексте. Для хранения такой информации отлично подходит словарь. При этом помните, что в словаре хранятся элементы только с уникальными ключами. Чтобы проверить, существует ли уже элемент в словаре с определенным ключом, можно использовать метод ContainsKey()"
        }
      ]
    }
  ]
}