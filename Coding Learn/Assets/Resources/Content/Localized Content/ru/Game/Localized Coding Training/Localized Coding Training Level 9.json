{
  "LinkedThemeID": "Sorting algorithms",
  "Title": "Алгоритмы сортировки",
  "SubThemes": [
    {
      "LinkedSubThemeID": "Introduction to algorithms",
      "Title": "Введение в алгоритмы",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Algorithms and their efficiency",
          "Title": "Алгоритмы и их эффективность",
          "Info": "В программировании нам часто приходится работать с набором данных, например искать в нем элементы или сортировать его. Для подобных целей мы используем алгоритмы, да и вообще, можно сказать, что вся программа - это один сплошной алгоритм.\nАлгоритм представляет собой последовательность шагов, которая призвана решить определенную задачу. Иными словами алгоритм - это способ решения этой задачи.\n\nВажным критерием алгоритма выступает эффективность. Алгоритм может прекрасно решать поставленную задачу, но при этом быть не эффективным. Как правило, под эффективностью алгоритма подразумевается время, за которое должен выполняться данный алгоритм. Можно ещё посмотреть на эффективность алгоритма с точки зрения требуемой для работы памяти, однако мы этого касаться не будем. \n"
        },
        {
          "LinkedTrainingInfoID": "Basic types of algorithm complexity",
          "Title": "Основные типы сложности алгоритмов",
          "Info": "Сложность алгоритма обозначает то, сколько операций в худшем случае выполнит алгоритм, прежде чем вернет верный ответ.  В зависимости от эффективности существует много типов алгоритмов, среди которых можно выделить следующие (перечислены в порядке уменьшения эффективности):\n\n1. Константный (const)\nВыполняет фиксированное количество операций, которые, как правило, требуют постоянного времени. Например, представим алгоритм, который печатает на экран первые 5 элементов из массива. Тогда в худшем случае ему придется выполнить 5 итераций, а если массив короткий, длиной всего 3, то алгоритм выполнить лишь 3 итерации. \n"
        },
        {
          "LinkedTrainingInfoID": "2. Logarithmic (logN)",
          "Title": "Логарифмический (logN)",
          "Info": "Здесь и далее N - размер входных данных в алгоритм.\nЛогарифмический алгоритм выполняется медленнее, чем программы с постоянным временем. Рост времени выполнения при росте N будет увеличиваться на некоторую постоянную величину.\n"
        },
        {
          "LinkedTrainingInfoID": "3. Linear (N)",
          "Title": "Линейный (N)",
          "Info": "Здесь выполнение метода зависит от n. Какое значение для n будет передано в метод, столько раз и будет выполняться цикл. То есть рост трудоемкости алгоритма для данного метода пропорционален значению n, поэтому его и называют линейный.\n"
        },
        {
          "LinkedTrainingInfoID": "4. Quadratic (N^2)",
          "Title": "Квадратичный (N^2)",
          "Info": "Как правило, методы, которые соответствуют данному алгоритму, содержит два цикл - внешний и вложенный, которые выполняются для всех значений вплоть до N.\n\nСуществуют и другие вариации, и одну из них мы затронем чуть позже. Стоит также отметить, что обычно сложность обозначается буквой “O”. Так например, для квадратичного алгоритма сложность будет O(N^2). У этой буквы есть определенный смысл, однако пока что мы не будем в него углубляться и будем считать, что она просто обозначает сложность.\n"
        },
        {
          "LinkedTrainingInfoID": "Bubble Sort",
          "Title": "Пузырьковая сортировка",
          "Info": "Сортировка пузырьком — один из самых известных алгоритмов сортировки. Здесь нужно последовательно сравнивать значения соседних элементов и менять числа местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале.\n\nЭтот алгоритм считается учебным и почти не применяется на практике из-за низкой эффективности: он медленно работает на тестах, в которых маленькие элементы (их называют «черепахами») стоят в конце массива. Однако на нём основаны многие другие методы, например, шейкерная сортировка и сортировка расчёской. Сложность такого алгоритма довольно большая - О(N^2)\n–GIF–"
        },
        {
          "LinkedTrainingInfoID": "Bubble Sort Algorithm",
          "Title": "Алгоритм пузырьковой сортировки",
          "Info": "Демонстрация в видеофрагменте"
        }
      ]
    },
    {
      "LinkedSubThemeID": "Comb Sorting",
      "Title": "Сортировка расчёской",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Comb Sorting",
          "Title": "Сортировка расчёской",
          "Info": "Сортировка расчёской\nСортировка расчёской — улучшение сортировки пузырьком. Её идея состоит в том, чтобы «устранить» элементы с небольшими значения в конце массива, которые замедляют работу алгоритма. Если при пузырьковой сортировке при переборе массива сравниваются соседние элементы, то при «расчёсывании» сначала берётся достаточно большое расстояние между сравниваемыми значениями, а потом оно сужается вплоть до минимального.\n\nПервоначальный разрыв нужно выбирать не случайным образом, а с учётом специальной величины — фактора уменьшения, оптимальное значение которого равно 1,247. Сначала расстояние между элементами будет равняться размеру массива, поделённому на 1,247; на каждом последующем шаге расстояние будет снова делиться на фактор уменьшения — и так до окончания работы алгоритма.\n–GIF–"
        },
        {
          "LinkedTrainingInfoID": "Comb Sorting Algorithm",
          "Title": "Алгоритм сортировки расческой",
          "Info": "Это лишь частичная реализация алгоритма. Здесь вам предстоит дополнить метод CombSort в местах троеточий, чтобы он заработал. \n–IMAGE–"
        }
      ]
    },
    {
      "LinkedSubThemeID": "Quick Sort",
      "Title": "Быстрая сортировка",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Quick Sort",
          "Title": "Быстрая сортировка",
          "Info": "Этот алгоритм входит в число одних из самых эффективных.\nОн состоит из трёх шагов. Сначала из массива нужно выбрать один элемент — его обычно называют опорным. Затем другие элементы в массиве перераспределяют так, чтобы элементы меньше опорного оказались до него, а большие или равные — после. А дальше рекурсивно применяют первые два шага к подмассивам справа и слева от опорного значения.\n–GIF–"
        },
        {
          "LinkedTrainingInfoID": "Quick Sort Implementation",
          "Title": "Реализация быстрой сортировки",
          "Info": "Показана в видеофрагменте"
        }
      ]
    },
    {
      "LinkedSubThemeID": "Merge Sort",
      "Title": "Сортировка слиянием",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Merge Sort",
          "Title": "Сортировка слиянием",
          "Info": "Сортировка слиянием пригодится для таких структур данных, в которых доступ к элементам осуществляется последовательно (например, для потоков). Здесь массив разбивается на две примерно равные части и каждая из них сортируется по отдельности. Затем два отсортированных подмассива сливаются в один.\n–GIF–"
        },
        {
          "LinkedTrainingInfoID": "Merge Sort Implementation",
          "Title": "Реализация сортировки слиянием",
          "Info": "Демонстрация видеофрагменте"
        }
      ]
    },
    {
      "LinkedSubThemeID": "Binary Search",
      "Title": "Бинарный поиск",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Binary Search",
          "Title": "Бинарный поиск",
          "Info": "Если вам дан случайный массив элементов и в нем требуется найти один из них, то вам ничего не остается, кроме как просто перебирать один элемент за другим, пока не встретится нужный. Такой алгоритм называется линейным поиском, и к сожалению, здесь невозможно совершить какой-нибудь хитрый трюк и существенно ускорить поиск.\n\nОднако если вам что-то известно о массиве данных, например, что он отсортирован, то ситуация резко меняется. Ведь если массив чисел отсортирован по возрастанию и вы, скажем, посмотрите на его средний элемент, то вы точно сможете определить, в какой половинке лежит ваше искомое число. Потому что, оно либо больше среднего элемента, и тогда нужно продолжить поиски в правой части массива, либо оно меньше, и тогда искать нужно слева. Или же если вам повезет, то средний элемент окажется искомым, и в таком случае поиск можно не продолжать. Обратите внимание: всего лишь на первой итерации можно сократить область искомого элемента вдвое! Именно в этом и состоит идея бинарно"
        },
        {
          "LinkedTrainingInfoID": "Binary Search Implementation",
          "Title": "Реализация бинарного  поиска",
          "Info": "Алгоритм бинарного поиска выглядит так:\n      1. “Делим” массив пополам и находим середину.\n      2. Сравниваем срединный элемент с заданным искомым элементом.\n      3. Если искомое число больше среднего — продолжаем поиск в правой части массива (если он отсортирован по возрастанию): делим ее пополам, повторяя пункт 2. Если же заданное число меньше — алгоритм продолжит поиск в левой части массива, снова возвращаясь к пункту 2.\n–IMAGE–"
        }
      ]
    }
  ]
}