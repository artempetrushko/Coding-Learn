{
  "LinkedThemeID": "Branches",
  "Title": "Ветвления",
  "SubThemes": [
    {
      "LinkedSubThemeID": "Introduction to branches",
      "Title": "Ветвления",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Branches",
          "Title": "Ветвления",
          "Info": "     Вы стали отлично справляться с написанием простых программ! Пришла пора освоить что-то более сложное.\n     Если вы вспомните, какими были ваши решения, то, возможно, заметите их общее сходство - все команды в них выполнялись <color=green>последовательно</color>, друг за другом. \"Но ведь нельзя сделать все программы такими!\" - скажете вы, и будете правы. Поэтому пришла пора рассказать вам про <color=green>ветвления</color>."
        },
        {
          "LinkedTrainingInfoID": "Branches. If, else constructs",
          "Title": "Ветвления. Конструкции if, else",
          "Info": "     <color=green>Ветвления</color> дают возможность выполнять <color=green>различный</color> код в зависимости от некоторого <color=green>условия</color>. Чтобы это осуществить, во многих языках, включая C#, есть специальные <color=green>условные конструкции if</color> и <color=green>else</color>.\n     Как их можно интерпретировать? Всё просто: если (<color=green>if</color>) некоторое условие истинно, то выполняется код, следующий после if в фигурных скобках; в противном случае (<color=green>else</color>) будет выполнена другая часть кода, следующая в скобках после else."
        },
        {
          "LinkedTrainingInfoID": "Logical operators and expressions",
          "Title": "Логические операторы и выражения",
          "Info": "     Ну хорошо, а что за условия должны выполняться и как их писать в коде? На самом деле, их вариаций крайне много, но мы начнём с простых и всем известных - математических.\n     Безусловно, вам известны такие условия, как <, >, <=, >=. Это <color=green>логические операторы</color>, и с их помощью мы и будем создавать условия. Например, в круглых скобках после if можно проверять, число А больше числа B или нет. Если да, выполнится код из секции if, в противном случае - из секции else.\n     Ну и коль скоро мы можем сравнивать числа, вы можете также сравнивать и <color=green>переменные</color>, хранящие их."
        }
      ]
    },
    {
      "LinkedSubThemeID": "Branches (continuation)",
      "Title": "Ветвления (продолжение)",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Branches (continued)",
          "Title": "Ветвления (продолжение)",
          "Info": "     Неплохо, теперь мы можем писать более сложные программы. Но всё равно есть проблема: пока что мы умеем реализовывать только 2 варианта развития событий. А как сделать так, чтобы у нас было <color=green>много</color> условий и так же много вариантов дальнейших действий?\n"
        },
        {
          "LinkedTrainingInfoID": "else if construct",
          "Title": "Конструкция else if",
          "Info": "     Конечно, мы могли бы попытаться в if и else записать ещё if и else, и порой так можно и нужно сделать. Но не всегда.\n     Куда более полезной более конструкция <color=green>else if</color> (\"иначе если\"). Она позволяет выполнить некоторый код, если условие в if ложно, но <color=green>другое условие</color> (которое написано в скобках после else if) истинно. Если же и оно будет ложно, то будет выполнен код из else.\n     Стоит отметить, что таких else if мы можем написать <color=green>сколь угодно много</color> и, таким образом, сделать программу очень гибкой. Главное, с этим не переборщить!"
        },
        {
          "LinkedTrainingInfoID": "Multiple conditions",
          "Title": "Множественные условия",
          "Info": "     Хотя else if позволяет учесть множество условий, иногда это может привести к разрастанию и дублированию кода, которых стоит избегать. Тем более когда можно использовать иной подход.\n     В условных конструкциях можно указывать не одно, а <color=green>несколько</color> условий. В этом нам помогут такие условные операторы, как <color=green>&&</color> (логическое <color=green>И</color>) и <color=green>||</color> (логическое <color=green>ИЛИ</color>).\n     Если между двумя условиями стоит &&, то выражение будет истинно, когда <color=green>оба условия истинны</color>. Если же будет стоять ||, для истинности выражения будет достаточно истинности <color=green>хотя бы одного из условий</color>."
        },
        {
          "LinkedTrainingInfoID": "And some more operators",
          "Title": "И ещё немного операторов",
          "Info": "     Прежде чем приступить к заданию, мы хотели рассказать ещё о некоторых полезных операторах.\n     Помимо тех, что мы упоминали ранее, есть также <color=green>==</color> и <color=green>!=</color>. Первый - оператор равенства, с его помощью можно проверить, равна ли левая часть (или, как принято её называть, <color=green>операнд</color>) правой. Второй работает с точностью наоборот: выражение будет истинно, если левый операнд не равен правому."
        }
      ]
    },
    {
      "LinkedSubThemeID": "Repetition 1",
      "Title": "Повторение",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Repetition",
          "Title": "Повторение",
          "Info": "     Немного отдохнём от теории, вместо этого вновь попрактикуемся использовать то, что мы изучили ранее. Используйте все те условные конструкции и операторы, которые посчитаете нужными!"
        }
      ]
    },
    {
      "LinkedSubThemeID": "Boolean type bool",
      "Title": "Логический тип bool",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Boolean type bool 1",
          "Title": "Логический тип bool",
          "Info": "     Мы с вами уже знаем немало условных выражений, которые оказываются крайне полезны в программировании. Всех их объединяет то, что они могут иметь два состояния - <color=green>быть истинными</color> и <color=green>быть ложными</color>. А потому они представляют собой <color=green>логический</color> тип данных - <color=green>bool</color>."
        },
        {
          "LinkedTrainingInfoID": "Boolean type bool 2",
          "Title": "Логический тип bool",
          "Info": "     Переменные типа <color=green>bool</color> могут принимать два значения - <color=green>true</color> (истина) и <color=green>false</color> (ложь). Эти же значения принимают и условные выражения, которые мы использовали ранее, поэтому их (выражения) можно присваивать переменным типа bool (их ещё называют <color=green>булевыми</color> переменными). Это позволяет сохранять результаты проверки на истинность и использовать в других условных конструкциях или возвращать в return."
        },
        {
          "LinkedTrainingInfoID": "Logic constructs and code-style 1",
          "Title": "Логические конструкции и code-style",
          "Info": "     Несколько рекомендаций по коду для логических выражений и bool:\n     - Имена булевых переменных должны быть заданы в виде вопроса, на который можно дать ответ \"Да\" или \"Нет\" (например, isNumberEven - \"Число чётное?\");\n     - Лучше не давать имена с частицей not и не проверять, чем те или иные объекты/явления НЕ являются. Если нужно проверить <color=green>отрицательность</color> утверждения, поставьте перед булевой переменной или логическим выражением оператор <color=green>!</color> (логическое <color=green>НЕ</color>) (при использовании с логическим выржанием нужно предварительно обернуть его в круглые скобки);"
        },
        {
          "LinkedTrainingInfoID": "Logic constructs and code-style 2",
          "Title": "Логические конструкции и code-style",
          "Info": "     - Если вы в блоке if и в блоке else лишь возвращаете true или false, то лучше заменить всю эту конструкцию на <color=green>return [условная конструкция];</color>. В процессе работы программы истинность выражения будет подсчитана и тут же возвращена из метода."
        }
      ]
    },
    {
      "LinkedSubThemeID": "Repetition 2",
      "Title": "Повторение",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Repetition",
          "Title": "Повторение",
          "Info": "     Теперь, когда мы ознакомились со всеми понятиями и конструкциями ветвлений, настало пора попрактиковаться. Причём на тех задачах, где потребуется всё, что мы с вами изучили ранее. Вперёд!"
        }
      ]
    },
    {
      "LinkedSubThemeID": "Switch-case construction",
      "Title": "Конструкция switch-case",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Switch-case construction",
          "Title": "Конструкция switch-case",
          "Info": "     Хоть конструкции if, else и else if - это здорово, порой можно решить задачу более изящным способом. И имя этому способу - <color=green>switch</color>.\n     Конструкция <color=green>switch</color> позволяет сравнить переданное ей значение с некоторыми вариантами (<color=green>case</color>-ами). В случае совпадения выполняется предусмотренный для этого случая код."
        },
        {
          "LinkedTrainingInfoID": "End case",
          "Title": "Завершение case",
          "Info": "     Каждый case завершается некоторым <color=green>словом-оператором</color>. Их несколько, но мы будем использовать самый популярный - <color=green>break</color>, чтобы программа не стала проверять следующие кейсы и вышла из switch. Как видите, в case не используются фигурные скобки, поэтому код становится короче и чище."
        },
        {
          "LinkedTrainingInfoID": "Operator default",
          "Title": "Оператор default",
          "Info": "     Кроме case, в конструкции switch можно использовать полезный оператор <color=green>default</color>. Он позволяет выполнить некоторый код в том случае, когда переданное значение <color=green>не совпало ни с одним case-ом</color>. Если же один из case-ов сработал, код в default будет пропущен."
        }
      ]
    },
    {
      "LinkedSubThemeID": "Repetition 3",
      "Title": "Повторение",
      "Infos": [
        {
          "LinkedTrainingInfoID": "Repetition",
          "Title": "Повторение",
          "Info": "     Прекрасно! Наш арсенал условных конструкций пополнился мощным <color=green>switch-ем</color>, а значит теперь многие задачи вам по плечу! Конечно, мы разобрали не все возможности и аспекты ветвлений, но даже изученных вам будет вполне достаточно. Напоследок, чтобы закрепить пройденный материал, решим ещё одну задачу!"
        }
      ]
    }
  ]
}